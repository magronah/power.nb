[{"path":"https://michaelagronah.com/power.nb/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 power.nb authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (‚ÄúSoftware‚Äù), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED ‚Äú‚Äù, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://michaelagronah.com/power.nb/articles/stub.html","id":"package-description-and-functionalities","dir":"Articles","previous_headings":"","what":"Package Description and Functionalities","title":"Power and Sample Size Estimation for Microbiome Analysis","text":"power.nb package developed estimating statistical power sample sizes differential abundance microbiome studies. package presents novel methods estimating statistical power individual taxa (feature, OTU/ASV, species) sample size calculation accounting effect sizes mean abundance taxa. power.nb also presents two novel microbiome data simulations frameworks: Cask's RRSim. method implemented MixGaussSim models distribution mean abundance taxa distribution fold change (function mean abundance taxa) finite Mixture Gaussian distributions. Microbiome count data simulated negative binomial distribution. Detailed description MixGaussSim method presented paper ‚ÄúInvestigating statistical power differential abundance studies‚Äù (Agronah Bolker 2025). RRSim (simulation method still development functions RRSim yet tested), hand models mean abundance taxa jointly mixed-effects model accounting correlations among taxa within subjects zero inflation microbiome data. Given high dimensionality microbiome data (usually hundreds thousands taxa), modelling correlations taxa requires estimating thousands even millions parameters correlation matrix. RRSim uses reduced rank functionality implemented glmmTMB (Magnusson et al. 2017) packages reduce number parameter estimates required variance-correlation matrix. Details method presented thesis ‚ÄúNovel Approach Simulation-Based Power Estimation Joint Modeling Microbiome Counts‚Äù (Agronah 2025)","code":""},{"path":"https://michaelagronah.com/power.nb/articles/stub.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"Power and Sample Size Estimation for Microbiome Analysis","text":"Install package GitHub using devtools:","code":"install.packages(\"devtools\") devtools::install_github(\"magronah/power.nb\")"},{"path":"https://michaelagronah.com/power.nb/articles/stub.html","id":"simulating-microbiome-data","dir":"Articles","previous_headings":"","what":"Simulating microbiome data","title":"Power and Sample Size Estimation for Microbiome Analysis","text":"Since goal differential abundance studies identify taxa differ significantly groups, statistical power must estimated level individual taxa. complexity microbiome data, analytical approaches based theoretical distributions test statistics (e.g., non-central t chi-squared distributions) feasible (Arnold et al. 2011). Therefore, power estimation typically relies simulation-based methods can mimic characteristics real microbiome data. Statistical power given taxon depends mean abundance effect size (defined package fold changes) (Agronah Bolker 2025). Thus, estimating distributions mean abundance fold change taxa explicitly offer great benefit estimation statistical power individual taxon. use MixGaussSim simulation approach simulate microbiome data power calculation due flexibility modelling distributions taxa mean abundances effect sizes explicitly well relationship.","code":""},{"path":"https://michaelagronah.com/power.nb/articles/stub.html","id":"two-ways-to-obtain-parameters-for-data-simulation-using-mixgausssim","dir":"Articles","previous_headings":"Simulating microbiome data","what":"Two ways to obtain parameters for data simulation using MixGaussSim","title":"Power and Sample Size Estimation for Microbiome Analysis","text":"one two ways obtain parameters MixGaussSim method data simulation. Users can: 1. pre-specify set parameters: help users decide plausible parameter values, run MixGaussSim microbiome datasets used paper ‚ÄúMicrobiome differential abundance methods produce different results across 38 datasets‚Äù (Nearing et al. 2022) presented parameter estimates obtained datasets (see Appendix parameter estimates datasets ). 2. estimate parameters existing dataset: Secondly, users can also obtain estimates directly fitting model implemented MixGaussSim existing datasets. following steps outlines process estimating parameters existing dataset.","code":""},{"path":"https://michaelagronah.com/power.nb/articles/stub.html","id":"dataset","dir":"Articles","previous_headings":"Simulating microbiome data","what":"Dataset","title":"Power and Sample Size Estimation for Microbiome Analysis","text":"use subset Obesity dataset, one datasets analyzed (Nearing et al. 2022). full dataset contains 52 samples 1203 taxa.","code":"##Load libraries library(tidyverse) library(dplyr) library(power.nb) library(patchwork)  data_path =  system.file(\"pkgdata\", package = \"power.nb\") ##Read count data and metadata data <- read.table(   file.path(data_path, \"ob_ross_ASVs_table.tsv\"),   header = TRUE, sep = \"\\t\",   check.names = FALSE, comment.char = \"\",    row.names = 1 )  metadata <- read.table(   file.path(data_path, \"ob_ross_metadata.tsv\"),   header = TRUE, sep = \"\\t\",   check.names = FALSE, comment.char = \"\" )  metadata <- metadata %>%   setNames(c(\"SampleID\", \"Groups\"))  dim(data); dim(metadata) ## [1] 1203   52 ## [1] 52  2 head(data); head(metadata) ##           BD0017v13 BD0027v13 BD0022v13 BD0040v13 BD0044v13 BD0057v13 BD0115v13 ## denovo619         0         0         0         0         0         0         0 ## denovo618         0         0         0         0         0         0         0 ## denovo617         0         0         0         0         9         0         0 ## denovo616         0         0         0         0         0         0         0 ## denovo615         0         0         0         0         0         0         0 ## denovo614         0         0         0         0         0         0         0 ##           BD0190v13 BD0072v13 BD0112v13 BD0246v13 BD0247v13 BD0266v13 BD0235v13 ## denovo619         8         0         0         0         0         0         0 ## denovo618         0         0         0         0         0         0         0 ## denovo617         0         0         0         1         3         0         0 ## denovo616         0         0         0         0         0         0         0 ## denovo615         0         0         0         0         0         0         0 ## denovo614         0         0         0         1         1         8         0 ##           BD0295v13 BD0255v13 BD0300v13 BD0331v13 BD0321v13 BD0351v13 BD0409v13 ## denovo619         1         0         0         0         0         0         8 ## denovo618         0         0         0         0         0         0         0 ## denovo617         0         0         0         0         0         2         0 ## denovo616         0         0         0         0        27         0         0 ## denovo615         0         0         0         0         0         0         0 ## denovo614         0         0         1         0         3         1         1 ##           BD0410v13 BD0375v13 BD0414v13 BD0422v13 BD0464v13 BD0571v13 BD0578v13 ## denovo619         0         0         0         0         0         0         0 ## denovo618         0         0         0         0         0         0         1 ## denovo617         0         0         1         0         0         0         0 ## denovo616         0         0         0         0         0         0         0 ## denovo615         0         0         0         0         3         0         0 ## denovo614         1         0         1         0         0         0         0 ##           BD0587v13 BD0592v13 BD0594v13 BD0610v13 BD0611v13 BD0613v13 BD0636v13 ## denovo619         0         0         0         1         0         0         0 ## denovo618         2         0         0         0         0        18         0 ## denovo617         1         0         1         0         0         0         0 ## denovo616         0         0         0         0         0         0         0 ## denovo615         0         0         0         0         0         0         4 ## denovo614         1         0         0         0         0         2         0 ##           BD0616v13 BD0653v13 BD0643v13 BD0654v13 BD0673v13 BD0735v13 BD0760v13 ## denovo619         0         0         0         1         0         0         0 ## denovo618         0         0         0         0         0         0         0 ## denovo617         0         4         0         0         0         5         0 ## denovo616         0         0         0         0         0         0         0 ## denovo615         0         0         0         0         0         0         0 ## denovo614         0         2         0         1         0         0         0 ##           BD0777v13 BD0758v13 BD0789v13 BD0791v13 BD0821v13 BD0786v13 BD0790v13 ## denovo619         0         0         0         0         7         0         0 ## denovo618         0         0         0         0         6         0         0 ## denovo617         0         0         0         0         0         0         0 ## denovo616         0         0         0         0         0         0         0 ## denovo615         0        20         0         0         0         0         0 ## denovo614         0         0         0         0         0         0         0 ##           BD0913v13 BD0954v13 BD0981v13 ## denovo619         0         0         0 ## denovo618         0         0         0 ## denovo617         0         0         0 ## denovo616         0         0         0 ## denovo615         0         0         0 ## denovo614         0         1         0 ##    SampleID Groups ## 1 BD0017v13     OB ## 2 BD0027v13      H ## 3 BD0022v13      H ## 4 BD0040v13     OB ## 5 BD0044v13     OB ## 6 BD0057v13      H"},{"path":"https://michaelagronah.com/power.nb/articles/stub.html","id":"pre-filtering-low-abundant-taxa","dir":"Articles","previous_headings":"Simulating microbiome data","what":"Pre-filtering low abundant taxa","title":"Power and Sample Size Estimation for Microbiome Analysis","text":"Low abundant tax exhibit high variability, posing challenges detecting significant differences groups (Love, Huber, Anders 2014). Pre-filtering steps, routinely done differential abundance analysis, used filter low abundant taxa. filter taxa less 10 count less 5 samples.","code":"filter_data  =  filter_low_count(countdata     =  data,                                 metadata       =  metadata,                                 abund_thresh   =  2,                                 sample_thresh  =  2,                                 sample_colname =  \"SampleID\",                                 group_colname  =  \"Groups\")  dim(filter_data) ## [1] 903  52"},{"path":"https://michaelagronah.com/power.nb/articles/stub.html","id":"fold-change-and-dispersion-estimation","dir":"Articles","previous_headings":"Simulating microbiome data","what":"Fold change and Dispersion Estimation","title":"Power and Sample Size Estimation for Microbiome Analysis","text":"estimate fold change taxon dispersion parameters using negative binomial model implemented DESeq2 package (Love, Huber, Anders 2014). negative binomial model widely used microbiome RNA-seq analyses implemented NBZIMM (Yi 2020) edgeR R packages (Robinson, McCarthy, Smyth 2010). model implemented DESeq2 package described follows: Let KijK_{ij} represent observed count ithi^{\\text{th}} taxon jthj^{\\text{th}} sample. model assumes thatKij‚àºNB(Œºij,Œ±ij),K_{ij} \\sim \\text{NB}(\\mu_{ij}, \\alpha_{ij}), mean defined Œºij=sjqij\\mu_{ij} = s_j q_{ij}, sjs_j normalization factor sample jj. expected abundance prior normalization, qijq_{ij}, modeled aslogqij=‚àërxjrŒ≤ir,\\log q_{ij} = \\sum_r x_{jr} \\beta_{ir}, xjrx_{jr} denoting covariates Œ≤ir\\beta_{ir} associated coefficients. dispersion parameter assumed constant across samples taxon, Œ±ij=Œ±i\\alpha_{ij} = \\alpha_i. formulation links variance mean throughVar(Kij)=Œºi+Œ±iŒºi2.\\mathrm{Var}(K_{ij}) = \\mu_i + \\alpha_i \\mu_i^2. Estimation regression coefficients Œ≤ÃÇir\\hat{\\beta}_{ir} dispersion parameters Œ±ÃÇ\\hat{\\alpha}_i carried using empirical Bayes shrinkage procedures implemented DESeq2 package Anders Huber (2010).","code":"unique(metadata$Groups) ## [1] \"OB\" \"H\" foldchange_est <- deseqfun(countdata      =   filter_data,                            metadata       =   metadata,                            alpha_level    =   0.1,                            ref_name       =  \"H\",                            group_colname  =  \"Groups\",                            sample_colname =  \"SampleID\")  logfoldchange =  foldchange_est$deseq_estimate$log2FoldChange  head(logfoldchange) ## [1]  0.32958211 -0.90669149  0.23052500 -0.51398232 -0.02770075 -0.82149821"},{"path":"https://michaelagronah.com/power.nb/articles/stub.html","id":"modeling-the-distribution-of-log-mean-counts","dir":"Articles","previous_headings":"Simulating microbiome data","what":"Modeling the distribution of log mean counts","title":"Power and Sample Size Estimation for Microbiome Analysis","text":"modelled log mean abundance (defined logarithm arithmetic mean abundance across control treatment groups) finite mixture Gaussian distributions. determine optimal number mixture components, denoted kk, employed parametric bootstrap approach sequentially compare models kk k+1k+1 components. Let observed data denoted ùê≤=(y1,y2,‚Ä¶,yn)\\mathbf{y} = (y_1, y_2, \\dots, y_n), yiy_i represents log mean abundance ithi^{\\text{th}} taxon. mixture model kk components given fk(yi‚à£ùõâk)=‚àëj=1kœÄj,kœï(yi‚à£Œºj,k,œÉj,k2),f_k(y_i \\mid \\boldsymbol{\\theta}_k) = \\sum_{j=1}^{k} \\pi_{j,k} \\, \\phi(y_i \\mid \\mu_{j,k}, \\sigma_{j,k}^2), œÄj,k\\pi_{j,k} mixing proportions satisfying ‚àëj=1kœÄj,k=1\\sum_{j=1}^{k} \\pi_{j,k} = 1, œï(‚ãÖ‚à£Œº,œÉ2)\\phi(\\cdot \\mid \\mu, \\sigma^2) denotes normal density mean Œº\\mu variance œÉ2\\sigma^2. test whether adding additional component improves model fit, formulated hypotheses : ‚Äô {H0:ùê≤‚àºfk(yi‚à£ùõâk)(data follow k-component mixture model)Ha:ùê≤‚àºfk+1(yi‚à£ùõâk+1)(data follow (k+1)-component mixture model) \\begin{cases}  H_0: \\mathbf{y} \\sim f_k(y_i \\mid \\boldsymbol{\\theta}_k) & \\textrm{(data follow $k$-component mixture model)} \\\\ H_a: \\mathbf{y} \\sim f_{k+1}(y_i \\mid \\boldsymbol{\\theta}_{k+1}) & \\textrm{(data follow $(k+1)$-component mixture model)} \\end{cases} {=latex}‚Äô test statistic likelihood ratio statistic: ‚Äô Œõ=2[‚Ñìk+1(ùõâÃÇk+1)‚àí‚Ñìk(ùõâÃÇk)],\\Lambda = 2 \\left[ \\ell_{k+1}(\\widehat{\\boldsymbol{\\theta}}_{k+1}) - \\ell_{k}(\\widehat{\\boldsymbol{\\theta}}_{k}) \\right], ‚Ñìk(ùõâÃÇk)\\ell_{k}(\\widehat{\\boldsymbol{\\theta}}_{k}) ‚Ñìk+1(ùõâÃÇk+1)\\ell_{k+1}(\\widehat{\\boldsymbol{\\theta}}_{k+1}) maximized log-likelihoods kk- (k+1)(k+1)-component models, respectively. {=latex}‚Äô approximate null distribution Œõ\\Lambda, performed parametric bootstrap using B=100B = 100 bootstrap samples generated H0H_0. bootstrap replicate b=1,‚Ä¶,Bb = 1, \\dots, B, data simulated fitted kk-component model, null alternative models re-fitted obtain Œõ(b)\\Lambda^{(b)}. empirical pp-value computed p=1B‚àëb=1BI(Œõ(b)‚â•Œõobs),p = \\frac{1}{B} \\sum_{b=1}^{B} \\left( \\Lambda^{(b)} \\ge \\Lambda_{\\text{obs}} \\right), Œõobs\\Lambda_{\\text{obs}} observed likelihood ratio statistic. p<0.05p < 0.05, null hypothesis H0H_0 rejected favor (k+1)(k+1)-component model. Testing proceeds sequentially k=1,2,‚Ä¶,5k = 1, 2, \\dots, 5 pp-value exceeds 5%5\\% significance threshold, point kk-component model last accepted test selected optimal mixture size (Benaglia et al. 2010).","code":"logmean    =  log(rowMeans(filter_data))  ### function to mute printing out messages about ### update on the number of iterations  quiet <- function(expr) {   out <- suppressWarnings(suppressMessages(     capture.output(res <- eval.parent(substitute(expr)))   ))   res}  logmeanFit =   quiet(logmean_fit(logmean, sig = 0.05,                                  max.comp = 4, max.boot = 100))  logmeanFit ## $param ##      lambda     sigma         mu ## 1 0.1982037 0.1841083 -1.4702824 ## 2 0.3594970 0.4703611 -0.7892082 ## 3 0.4422992 1.4529581  1.3381490 ##  ## $components ## [1] 3"},{"path":"https://michaelagronah.com/power.nb/articles/stub.html","id":"modelling-the-distribution-of-log-fold-change-estimates","dir":"Articles","previous_headings":"Simulating microbiome data","what":"Modelling the distribution of log fold change estimates","title":"Power and Sample Size Estimation for Microbiome Analysis","text":"also modelled log fold change taxa finite mixture Gaussian distributions. Fold change typically related mean abundance (Love, Huber, Anders 2014); therefore, expressed mean standard deviation parameters individual Gaussian components functions log mean abundance. Detailed description model fitted log fold changes presented paper ‚ÄúInvestigating statistical power differential abundance studies‚Äù (Agronah Bolker 2025).","code":"logfoldchangeFit <- quiet(logfoldchange_fit(logmean,                                             logfoldchange,                                             ncore = 3,                                             max_sd_ord = 2,                                             max_np = 5,                                             minval = -5,                                             maxval = 5,                                             itermax = 100,                                             NP = 800,                                             seed = 100))  logfoldchangeFit ## $par ## logitprob_1    mu_int_1    mu_int_2  mu_slope_1  mu_slope_2  logsd_.1_1  ## -4.55703267  0.03677531 -1.42836719  0.06345551 -0.81207193 -0.33404343  ##  logsd_.1_2  logsd_.L_1  logsd_.L_2  logsd_.Q_1  logsd_.Q_2  ##  1.45264954  0.38750859  2.81470432 -0.11822723  0.45802656  ##  ## $np ## [1] 2 ##  ## $sd_ord ## [1] 2 ##  ## $aic ## [1] 1779.056"},{"path":"https://michaelagronah.com/power.nb/articles/stub.html","id":"modelling-the-dispersion-estimates","dir":"Articles","previous_headings":"Simulating microbiome data","what":"Modelling the dispersion estimates","title":"Power and Sample Size Estimation for Microbiome Analysis","text":"dispersion tends depend mean count abundance rarer taxa showing greater variability modeled dispersion nonlinear function mean, following approach implemented DESeq2. nonlinear function defined d=c0+c1m d = c_0 + \\frac{c_1}{m} dd mm denote scaled dispersion mean abundance respectively. term c0c_0 represents asymptotic dispersion level high abundance taxa, c1c_1 captures additional dispersion variability. procedure enables estimation dispersion values corresponding given mean counts, facilitating use downstream simulations power analyses.","code":"dispersion    =  foldchange_est$dispersion dispersionFit =  dispersion_fit(dispersion, logmean) dispersionFit$param ##   asymptDisp extraPois ## 1   18.12243  2.597064"},{"path":"https://michaelagronah.com/power.nb/articles/stub.html","id":"simulate-count-microbiome-data","dir":"Articles","previous_headings":"Simulating microbiome data","what":"Simulate count microbiome data","title":"Power and Sample Size Estimation for Microbiome Analysis","text":"simulate microbiome data, first simulate log mean counts corresponding log fold changes. simulated log mean counts represent overall log mean counts (.e., log arithmetic mean counts treatment control groups). use simulated log mean count estimate corresponding dispersion values sample fitted nonlinear function described equation (see section Modelling Distribution Log Fold Changes). Using simulated log mean counts fold changes, now compute group specific mean counts (.e., mean counts taxa control group mean count taxa treatment group). simulate microbiome count data negative binomial distribution using group specific mean counts estimated dispersion values.","code":""},{"path":"https://michaelagronah.com/power.nb/articles/stub.html","id":"simulate-log-mean-count-and-log-fold-change","dir":"Articles","previous_headings":"Simulating microbiome data > Simulate count microbiome data","what":"Simulate log mean count and log fold change","title":"Power and Sample Size Estimation for Microbiome Analysis","text":"","code":"### Simulated log mean count and log foldchange from the fitted  ### log mean count and log foldchange models  logmean_param       =  logmeanFit$param logfoldchange_param =  logfoldchangeFit  notu  = dim(filter_data)[1] notu ## [1] 903 logmean_sim  =  logmean_sim_fun(logmean_param, notu)  logfoldchange_sim  =  logfoldchange_sim_fun(logmean_sim = logmean_sim,                                             logfoldchange_param =                                              logfoldchange_param,                                             max_lfc  = 15,                                             max_iter = 30000)  head(logfoldchange_sim) ## [1]  1.67394732 -0.72483152  0.09834296  0.73556137 -0.13028789 -0.51072261"},{"path":"https://michaelagronah.com/power.nb/articles/stub.html","id":"simulate-counts-from-the-negative-binomial-distribution","dir":"Articles","previous_headings":"Simulating microbiome data > Simulate count microbiome data","what":"Simulate counts from the negative binomial distribution","title":"Power and Sample Size Estimation for Microbiome Analysis","text":"Estimating dispersion values done internally within countdata_sim_fun function.","code":"nsim = 4 ntreat = sum(metadata$Groups == \"OB\") ncont  = sum(metadata$Groups == \"H\") dispersion_param  =  dispersionFit$param  countdata_sims = countdata_sim_fun(logmean_param,                                    logfoldchange_param,                                    dispersion_param,                                    nsamp_per_group = NULL,                                    ncont = ncont,                                    ntreat = ntreat,                                    notu,                                    nsim = nsim,                                    disp_scale = 0.7,                                    max_lfc = 15,                                    maxlfc_iter = 1000,                                    seed = 121) ## mixtools package, version 2.0.0.1, Released 2022-12-04 ## This package is based upon work supported by the National Science Foundation under Grant No. SES-0518772 and the Chan Zuckerberg Initiative: Essential Open Source Software for Science (Grant No. 2020-255193). names(countdata_sim_fun) ## NULL dim(countdata_sims$treat_countdata_list$sim_1) ## [1] 903  31 dim(countdata_sims$control_countdata_list$sim_1) ## [1] 903  21 dim(countdata_sims$countdata_list$sim_1) ## [1] 903  52 dim(countdata_sims$metadata_list$sim_1) ## [1] 52  2 length(countdata_sims$logfoldchange_list$sim_1) ## [1] 903 length(countdata_sims$logmean_list$sim_1) ## [1] 903"},{"path":"https://michaelagronah.com/power.nb/articles/stub.html","id":"comparing-the-distributions-between-simulated-count-d-of-mean-count-and-fold-change-from-simulation-with-actual-data","dir":"Articles","previous_headings":"Simulating microbiome data > Simulate count microbiome data","what":"Comparing the distributions between simulated count d of mean count and fold change from simulation with actual data","title":"Power and Sample Size Estimation for Microbiome Analysis","text":"compare following comparisons simulation actual dataset come distribution variances counts taxa means taxa simulation actual dataset","code":"library(rlist) library(latex2exp)   # means dd_mean <- rbind(   data.frame(value = apply(countdata_sims$countdata_list$sim_1, 1, mean),              type = \"simulation\"),   data.frame(value = apply(filter_data, 1, mean),              type = \"observation\") )  p1_ <- ggplot(dd_mean, aes(x = log(value + 1e-8))) +   geom_density(aes(colour = type), linewidth = 1.2,                data = subset(dd_mean, type == \"simulation\")) +   geom_density(linetype = \"dashed\", colour = \"black\", linewidth = 1.2,                data = subset(dd_mean, type == \"observation\")) +   theme_bw()  # variances dd_var <- rbind(   data.frame(value = apply(countdata_sims$countdata_list$sim_1, 1, var),              type = \"simulation\"),   data.frame(value = apply(filter_data, 1, var),              type = \"observation\") )  p2_ <- ggplot(dd_var, aes(x = log(value + 1e-8))) +   geom_density(aes(colour = type), linewidth = 1.2,                data = subset(dd_var, type == \"simulation\")) +   geom_density(linetype = \"dashed\", colour = \"black\", linewidth = 1.2,                data = subset(dd_var, type == \"observation\")) +   theme_bw()  (p1_ | p2_) + patchwork::plot_layout(guides = \"collect\") pp1= apply(countdata_sims$countdata_list$sim_1, 1, function(x){mean(x)}) pp2= apply(filter_data, 1, function(x){mean(x)})  pp11= apply(countdata_sims$countdata_list$sim_1, 1, function(x){var(x)}) pp21= apply(filter_data, 1, function(x){var(x)})  dd_ = data.frame(mean = c( as.numeric(pp2),as.numeric(pp1)),                  var = c( as.numeric(pp21),as.numeric(pp11)),                 type = rep(c(\"observation\",\"simulation\"), each = notu))   p1_ = ggplot(dd_, aes(x = log(mean), group = type, colour = type)) + geom_density() + theme_bw()  p2_ = ggplot(dd_, aes(x = log(var), group = type, colour = type)) + geom_density() + theme_bw()                   (p1_|p2_) + plot_layout(guides = \"collect\") ## Warning: Removed 1 row containing non-finite outside the scale range (`stat_density()`). ## Removed 1 row containing non-finite outside the scale range (`stat_density()`). compare_dataset <- function(countdata_sim_list,countdata_obs,method = c(\"var\", \"mean\")){      # Check if method is either \"var\" or \"mean\"   if (!(method %in% c(\"var\", \"mean\"))) {     stop(\"Invalid method. Please choose either 'var' or 'mean'.\")   }      # Calculate variance or mean based on the chosen method   if (method == \"var\") {     calc_func <- stats::var     xlab_text <- \"$\\\\log$(variance of taxa)\"   } else {     calc_func <- mean     xlab_text <- \"$\\\\log$(mean of taxa)\"   }      # Create a list combining simulation data and observed data   dlist <- list.append(countdata_sim_list, obs_filt = countdata_obs)      # Calculate variance or mean for each dataset in the list   vars <- dlist |> purrr::map(~ apply(., 1, calc_func)) |>     purrr::map_dfr(~ tibble(var = .), .id = \"type\")      # Separate observed and simulated data   vars_obs <- vars[vars$type == \"obs_filt\", ]   vars_sim <- vars[vars$type != \"obs_filt\", ]      # Create ggplot for visualization   p <- ggplot(vars_sim, aes(x = log(var), colour = type)) +      geom_density(lwd = 1.5) +     geom_density(data = vars_obs, aes(x = log(var)),                   colour = \"black\", linetype = \"dashed\", lwd = 1.5) +     xlab(TeX(xlab_text)) + theme_bw()      return(p) }                                     countdata_sim_list =  countdata_sims$countdata_list[1] countdata_obs      =  filter_data p11 = compare_dataset(countdata_sim_list,countdata_obs,method = \"mean\") p12 = compare_dataset(countdata_sim_list,countdata_obs,method = \"var\") (p11|p12) + plot_layout(guides = \"collect\") ## Warning: Removed 1 row containing non-finite outside the scale range (`stat_density()`). ## Removed 1 row containing non-finite outside the scale range (`stat_density()`). dim(countdata_obs) ## [1] 903  52"},{"path":"https://michaelagronah.com/power.nb/articles/stub.html","id":"estimating-statistical-power-for-individual-taxa","dir":"Articles","previous_headings":"","what":"Estimating Statistical Power for Individual Taxa","title":"Power and Sample Size Estimation for Microbiome Analysis","text":"estimate statistical power given taxon probability rejecting null hypothesis mean abundance control treatment groups given taxon. estimate statistical power various combinations log mean abundance log fold change, fitted shape-constrained generalized additive model (GAM) (Pya Wood 2015). event given taxon significantly different groups treated Bernoulli trial. model predicting statistical power function log fold change log mean abundance given : y‚àºBernoulli(pi)pi=11+e‚àíŒ∑Œ∑=Œ≤0+f1(x1,x2)+œµ,\\begin{align} y &\\sim \\text{Bernoulli}(p_i) \\\\ p_i &= \\frac{1}{1 + e^{-\\eta}} \\\\ \\eta &= \\beta_0 + f_1(x_1, x_2) + \\epsilon, \\end{align} : yy binary value (1 p-value critical threshold, 0 otherwise); pip_i estimated statistical power taxon ii; Œ≤0\\beta_0 œµ\\epsilon intercept error terms, respectively; predictors x1x_1 x2x_2 represent log mean abundance log fold change, respectively; f1(‚ãÖ)f_1(\\cdot) two-dimensional smoothing surface, generated using tensor product smooth log mean abundance log fold change. Power fold change positively correlated. Additionally, effect sizes highly abundant taxa likely detected‚Äîhence higher power‚Äîrare taxa. account relationships, function f1f_1 constrained monotonically increasing function log mean abundance log fold change. used DESeq2 package compute p-values taxon, applying Benjamini Hochberg method false discovery rate (FDR) correction. used default critical p-value threshold 0.1 DESeq2 package. follow steps outlines power estimation procedure:","code":""},{"path":"https://michaelagronah.com/power.nb/articles/stub.html","id":"estimate-p-values-associated-with-simulated-fold-changes","dir":"Articles","previous_headings":"Estimating Statistical Power for Individual Taxa","what":"Estimate p-values associated with simulated fold changes","title":"Power and Sample Size Estimation for Microbiome Analysis","text":"train GAM sufficiently large sample size, generate multiple microbiome count datasets following procedure described section Simulate count microbiome data. estimate p-values associated simulated fold changes using DESeq2 package.","code":"countdata_list  =   countdata_sims$countdata_list metadata_list   =   countdata_sims$metadata_list desq_est   =   quiet(deseq_fun_est(metadata_list =  metadata_list,                             countdata_list =  countdata_list,                             alpha_level    =  0.1,                             group_colname  = \"Groups\",                             sample_colname = \"Samples\",                             num_cores      =  4,                             ref_name       = \"control\"))  names(desq_est$sim_1) ## [1] \"logfoldchange\"  \"dispersion\"     \"deseq_estimate\" \"deseq_object\"   ## [5] \"metadata\"       \"countdata\" deseq_est_list     =    lapply(desq_est, function(x){x$deseq_estimate})"},{"path":"https://michaelagronah.com/power.nb/articles/stub.html","id":"fitting-the-generalized-additive-model-gam","dir":"Articles","previous_headings":"Estimating Statistical Power for Individual Taxa","what":"Fitting the Generalized Additive Model (GAM)","title":"Power and Sample Size Estimation for Microbiome Analysis","text":"now fit GAM predicting statistical power individual taxon.","code":"true_lmean_list       =    countdata_sims$logmean_list true_lfoldchange_list =    countdata_sims$logfoldchange_list  gamFit <- gam_fit(deseq_est_list,                   true_lfoldchange_list,                   true_lmean_list,                   grid_len = 50,                   alpha_level=0.1)  #plot(gamFit$fit_2d)"},{"path":"https://michaelagronah.com/power.nb/articles/stub.html","id":"contour-plot-showing-power-for-various-combinations-of-mean-abundance-and-fold-change","dir":"Articles","previous_headings":"Estimating Statistical Power for Individual Taxa","what":"Contour plot showing power for various combinations of mean abundance and fold change","title":"Power and Sample Size Estimation for Microbiome Analysis","text":"","code":"cont_breaks     =  seq(0,1,0.1) combined_data   =  gamFit$combined_data power_estimate  =  gamFit$power_estimate  contour_plot <- contour_plot_fun(combined_data,                                  power_estimate,                                  cont_breaks) contour_plot"},{"path":[]},{"path":"https://michaelagronah.com/power.nb/articles/stub.html","id":"simulate-count-data-for-various-ranges-of-sample-sizes","dir":"Articles","previous_headings":"Sample size calculation","what":"Simulate count data for various ranges of sample sizes","title":"Power and Sample Size Estimation for Microbiome Analysis","text":"","code":"nsim = 50 nsamp_vec = c(20, 50, 70) countdata_sims_list  =  list() for(j in 1:length(nsamp_vec)){   countdata_sims_list[[j]]  =  countdata_sim_fun(logmean_param,                                                  logfoldchange_param,                                                  dispersion_param,                                                  nsamp_per_group = nsamp_vec[j],                                                  ncont  = NULL,                                                  ntreat = NULL,                                                  notu,                                                  nsim = nsim,                                                  disp_scale = 0.3,                                                  max_lfc = 15,                                                  maxlfc_iter = 1000,                                                  seed = 121) }  names(countdata_sims_list) = paste0(\"sample_\",nsamp_vec)"},{"path":"https://michaelagronah.com/power.nb/articles/stub.html","id":"estimate-p-values-associated-to-fold-changes-for-each-taxa-for-simulated-data-per-sample-size","dir":"Articles","previous_headings":"Sample size calculation","what":"Estimate p-values associated to fold changes for each taxa for simulated data per sample size","title":"Power and Sample Size Estimation for Microbiome Analysis","text":"","code":"desq_est_list  =  list() for(i in 1:length(countdata_sims_list)){      countdata_list       =   countdata_sims_list[[i]]$countdata_list   metadata_list        =   countdata_sims_list[[i]]$metadata_list   desq_est_list[[i]]   =   deseq_fun_est(metadata_list =  metadata_list,                                countdata_list =  countdata_list,                                alpha_level    =  0.1,                                group_colname  = \"Groups\",                                sample_colname = \"Samples\",                                num_cores      =  4,                                ref_name       = \"control\")    }"},{"path":[]},{"path":[]},{"path":"https://michaelagronah.com/power.nb/articles/stub.html","id":"appendix","dir":"Articles","previous_headings":"","what":"Appendix","title":"Power and Sample Size Estimation for Microbiome Analysis","text":"Data description parameter estimates actual microbiome datasets","code":"##  ## Attaching package: 'kableExtra' ## The following object is masked from 'package:dplyr': ##  ##     group_rows"},{"path":"https://michaelagronah.com/power.nb/articles/stub.html","id":"acknowledgments","dir":"Articles","previous_headings":"","what":"Acknowledgments","title":"Power and Sample Size Estimation for Microbiome Analysis","text":"like express sincere gratitude Dr.¬†Jacob T. Nearing generosity granting us access 38 microbiome datasets used paper ‚ÄúMicrobiome differential abundance methods produce different results across 38 datasets‚Äù (Nearing et al. 2022). datasets invaluable developing, testing, validating R package power sample size calculation microbiome studies.","code":""},{"path":[]},{"path":"https://michaelagronah.com/power.nb/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Michael Agronah. Author, maintainer. Ben Bolker. Author.","code":""},{"path":"https://michaelagronah.com/power.nb/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Agronah M, Bolker B (2026). power.nb: Power Sample Size Calculation Differential Abundance Microbiome Studies. R package version 0.0.0.9000.","code":"@Manual{,   title = {power.nb: Power and Sample Size Calculation for Differential Abundance Microbiome Studies},   author = {Michael Agronah and Ben Bolker},   year = {2026},   note = {R package version 0.0.0.9000}, }"},{"path":[]},{"path":"https://michaelagronah.com/power.nb/index.html","id":"introduction","dir":"","previous_headings":"","what":"Introduction","title":"Power and Sample Size Calculation for Differential Abundance Microbiome Studies","text":"power.nb R package following features power.nb two simulators simulating microbiome data framework statistical power sample size calculation differential abundance microbiome studies","code":""},{"path":[]},{"path":"https://michaelagronah.com/power.nb/reference/contour_plot_fun.html","id":null,"dir":"Reference","previous_headings":"","what":"Contour plot for showing predicted power ‚Äî contour_plot_fun","title":"Contour plot for showing predicted power ‚Äî contour_plot_fun","text":"Contour plot showing predicted power","code":""},{"path":"https://michaelagronah.com/power.nb/reference/contour_plot_fun.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Contour plot for showing predicted power ‚Äî contour_plot_fun","text":"","code":"contour_plot_fun(   combined_data,   power_estimate,   cont_breaks,   multiple_samples = FALSE )"},{"path":"https://michaelagronah.com/power.nb/reference/contour_plot_fun.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Contour plot for showing predicted power ‚Äî contour_plot_fun","text":"combined_data data used fitting gam power_estimate predicted power cont_breaks breaks contour plot multiple_samples currently used","code":""},{"path":"https://michaelagronah.com/power.nb/reference/contour_plot_fun.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Contour plot for showing predicted power ‚Äî contour_plot_fun","text":"ggplot2 object","code":""},{"path":"https://michaelagronah.com/power.nb/reference/countdata_sim_fun.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate Count Data for Microbiome Studies ‚Äî countdata_sim_fun","title":"Simulate Count Data for Microbiome Studies ‚Äî countdata_sim_fun","text":"function simulates count data microbiome studies based log mean, log fold change, dispersion parameters. supports generating data multiple simulations allows flexibility specifying number control treatment samples samples per group.","code":""},{"path":"https://michaelagronah.com/power.nb/reference/countdata_sim_fun.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate Count Data for Microbiome Studies ‚Äî countdata_sim_fun","text":"","code":"countdata_sim_fun(   logmean_param,   logfoldchange_param,   dispersion_param,   nsamp_per_group = NULL,   ncont = NULL,   ntreat = NULL,   notu,   nsim = 1,   disp_scale = 0.3,   max_lfc = 15,   maxlfc_iter = 1000,   seed = NULL )"},{"path":"https://michaelagronah.com/power.nb/reference/countdata_sim_fun.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate Count Data for Microbiome Studies ‚Äî countdata_sim_fun","text":"logmean_param list parameters simulating log mean abundance. logfoldchange_param list parameters simulating log fold change, containing: par: Optimal parameters log fold change fitting. np: Number components log fold change model. sd_ord: Order polynomial standard deviation parameter. dispersion_param list dispersion parameters containing: asymptDisp: Asymptotic dispersion parameter. extraPois: Additional Poisson variation parameter. nsamp_per_group Number samples per group (control treatment). provided, ncont ntreat must specified. ncont Number control samples. Specify along ntreat nsamp_per_group provided. ntreat Number treatment samples. Specify along ncont nsamp_per_group provided. notu Number operational taxonomic units (OTUs) simulate. nsim Number simulations run. Default 1. disp_scale Scale parameter dispersion. Default 0.3. max_lfc Maximum allowable log fold change. Default 15. maxlfc_iter Maximum number iterations ensuring log fold change within max_lfc. Default 1,000. seed Seed value reproducibility. Default NULL.","code":""},{"path":"https://michaelagronah.com/power.nb/reference/countdata_sim_fun.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate Count Data for Microbiome Studies ‚Äî countdata_sim_fun","text":"list containing: countdata_list: list count data matrices simulation. metadata_list: list metadata data frames simulation. logmean_list: list log mean vectors simulation. logfoldchange_list: list log fold change vectors simulation. treat_countdata_list: list treatment count data matrices simulation. control_countdata_list: list control count data matrices simulation.","code":""},{"path":"https://michaelagronah.com/power.nb/reference/countdata_sim_fun.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate Count Data for Microbiome Studies ‚Äî countdata_sim_fun","text":"","code":"# Load required packages library(foreach) library(doParallel) #> Loading required package: iterators #> Loading required package: parallel # Define parameters logmean_param <- list(mu = 0, sigma = 1) logfoldchange_param <- list(par = rnorm(11), np = 2, sd_ord = 2) dispersion_param <- list(asymptDisp = 0.1, extraPois = 0.05)  # Simulate count data result <- countdata_sim_fun(   logmean_param = logmean_param,   logfoldchange_param = logfoldchange_param,   dispersion_param = dispersion_param,   nsamp_per_group = 10,   notu = 50,   nsim = 2,   seed = 123 ) #>  #> Attaching package: ‚Äòpurrr‚Äô #> The following objects are masked from ‚Äòpackage:foreach‚Äô: #>  #>     accumulate, when #> mixtools package, version 2.0.0.1, Released 2022-12-04 #> This package is based upon work supported by the National Science Foundation under Grant No. SES-0518772 and the Chan Zuckerberg Initiative: Essential Open Source Software for Science (Grant No. 2020-255193).  # Access simulation results countdata <- result$countdata_list[[1]] metadata <- result$metadata_list[[1]]"},{"path":"https://michaelagronah.com/power.nb/reference/deseq_fun_est.html","id":null,"dir":"Reference","previous_headings":"","what":"Fold change and p-value estimations for a many simulations ‚Äî deseq_fun_est","title":"Fold change and p-value estimations for a many simulations ‚Äî deseq_fun_est","text":"Fold change p-value estimations many simulations","code":""},{"path":"https://michaelagronah.com/power.nb/reference/deseq_fun_est.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fold change and p-value estimations for a many simulations ‚Äî deseq_fun_est","text":"","code":"deseq_fun_est(   metadata_list,   countdata_list,   alpha_level = 0.1,   group_colname,   sample_colname,   num_cores = 2,   ref_name = NULL )"},{"path":"https://michaelagronah.com/power.nb/reference/deseq_fun_est.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fold change and p-value estimations for a many simulations ‚Äî deseq_fun_est","text":"metadata_list : list metadata countdata_list : list otu count data alpha_level significance level determining differential expression. Default 0.1. group_colname column names groups conditions sample_colname column names samples num_cores : number cores ref_name reference level fold change calculation. NULL, reference level determined automatically ‚Äî default, factor level comes first used reference.","code":""},{"path":"https://michaelagronah.com/power.nb/reference/deseq_fun_est.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fold change and p-value estimations for a many simulations ‚Äî deseq_fun_est","text":"list logfoldchange log fold change estimates logmean  log mean count taxa (arithmetic mean taxa across subjects) dispersion: dispersion estimates taxa deseq_estimate  dataframe containing results deseq baseMean,log2FoldChange, lfcSE, pvalue, padj normalised_count normalised count data","code":""},{"path":"https://michaelagronah.com/power.nb/reference/deseqfun.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate log fold changes using DESeq2. ‚Äî deseqfun","title":"Estimate log fold changes using DESeq2. ‚Äî deseqfun","text":"function estimates log fold changes (LFC) microbiome count data using DESeq2 package. strongly recommended keep following defaults: minReplicatesForReplace=Inf cooksCutoff=TRUE independentFiltering=TRUE options particularly useful estimating fold changes fit mixture Gaussian distributions.","code":""},{"path":"https://michaelagronah.com/power.nb/reference/deseqfun.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate log fold changes using DESeq2. ‚Äî deseqfun","text":"","code":"deseqfun(   countdata,   metadata,   alpha_level = 0.1,   ref_name = NULL,   group_colname,   sample_colname,   minReplicatesForReplace = Inf,   cooksCutoff = TRUE,   independentFiltering = TRUE,   shrinkage_method = \"normal\" )"},{"path":"https://michaelagronah.com/power.nb/reference/deseqfun.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate log fold changes using DESeq2. ‚Äî deseqfun","text":"countdata matrix OTU count data rows represent taxa columns represent samples. metadata dataframe containing sample information two rows: one sample names one group names. alpha_level significance level determining differential expression. Default 0.1. ref_name reference level fold change calculation. NULL, reference level determined automatically ‚Äî default, factor level comes first used reference. group_colname column names groups conditions sample_colname column names samples minReplicatesForReplace DESeq2's parameter control minimum number replicates required replacing outliers dispersion estimation. Default Inf (replacement). cooksCutoff DESeq2's parameter removing outliers based Cook's distance. Default TRUE (outlier removal enabled). independentFiltering DESeq2's parameter independent filtering. Default TRUE. shrinkage_method DESeq2's shrinkage method fold changes. Default \"normal\". options include \"apeglm\" \"ashr\".","code":""},{"path":"https://michaelagronah.com/power.nb/reference/deseqfun.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate log fold changes using DESeq2. ‚Äî deseqfun","text":"list containing following elements: logfoldchange: vector log fold change estimates taxa. dispersion: vector dispersion estimates taxa. deseq_estimate: dataframe containing DESeq2 results, including baseMean, log2FoldChange, lfcSE, pvalue, padj. normalised_count: matrix normalized count data. dds: DESeq object","code":""},{"path":"https://michaelagronah.com/power.nb/reference/deseqfun.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate log fold changes using DESeq2. ‚Äî deseqfun","text":"","code":"# Example usage set.seed(101) nr = 10; nc =50 countdata <- matrix(rpois(500, 3), ncol = nc, nrow = nr) # Simulated OTU count data with 50 taxa and 10 samples countdata  <- as.data.frame(countdata) rownames(countdata)  <- paste(\"Sample\", 1:nr, sep = \"_\") colnames(countdata) <- paste(\"otu\", 1:nc, sep = \"_\") metadata <- data.frame(Samples = paste(\"Sample\", 1:nr, sep = \"_\"),              Groups = rep(c(\"Control\", \"Treatment\"), each = 5)) sample_colname = \"Samples\" group_colname  = \"Groups\"  result <- deseqfun(countdata, metadata, ref_name = \"Control\",                     minReplicatesForReplace = Inf,                     cooksCutoff = TRUE,                     sample_colname = \"Samples\",                     group_colname  = \"Groups\",                     independentFiltering = TRUE,                     shrinkage_method=\"normal\") #> estimating size factors #> estimating dispersions #> gene-wise dispersion estimates #> mean-dispersion relationship #> -- note: fitType='parametric', but the dispersion trend was not well captured by the #>    function: y = a/x + b, and a local regression fit was automatically substituted. #>    specify fitType='local' or 'mean' to avoid this message next time. #> final dispersion estimates #> fitting model and testing #> using 'normal' for LFC shrinkage, the Normal prior from Love et al (2014). #>  #> Note that type='apeglm' and type='ashr' have shown to have less bias than type='normal'. #> See ?lfcShrink for more details on shrinkage type, and the DESeq2 vignette. #> Reference: https://doi.org/10.1093/bioinformatics/bty895  # Examine the results result$logfoldchange  # Log fold changes #>        otu_1        otu_2        otu_3        otu_4        otu_5        otu_6  #> -0.007959025 -0.445880472 -0.394760811  0.233294799 -0.091829484  0.058651776  #>        otu_7        otu_8        otu_9       otu_10       otu_11       otu_12  #> -0.308246138 -0.308896891 -0.251029922 -0.252289726  0.039529520  0.160924136  #>       otu_13       otu_14       otu_15       otu_16       otu_17       otu_18  #>  0.194703220  0.192716051 -0.464400160  0.068904985 -0.097712013  0.053908758  #>       otu_19       otu_20       otu_21       otu_22       otu_23       otu_24  #> -0.363959631  0.156101373 -0.144220223 -0.013117419  0.028005740  0.150500957  #>       otu_25       otu_26       otu_27       otu_28       otu_29       otu_30  #>  0.042978792  0.027651694  0.141706746 -0.177098228  0.456759743 -0.309509409  #>       otu_31       otu_32       otu_33       otu_34       otu_35       otu_36  #>  0.035671304 -0.228363278  0.030497385 -0.256186889  0.044228160 -0.083204924  #>       otu_37       otu_38       otu_39       otu_40       otu_41       otu_42  #>  0.251044749  0.271340396 -0.148152551 -0.417094381  0.003548958  0.101448484  #>       otu_43       otu_44       otu_45       otu_46       otu_47       otu_48  #> -0.023449549 -0.062952952 -0.208034179 -0.104467686 -0.019733425  0.030671416  #>       otu_49       otu_50  #>  0.273876722  0.149311832  result$logmean  # Log mean counts #> NULL result$dispersion  # Dispersion estimates #>  [1] 0.23726334 0.11818891 0.12779467 0.20192426 0.17595129 0.07919315 #>  [7] 0.11134903 0.14821130 0.42777852 0.19140022 0.85818539 0.12657805 #> [13] 0.24094148 0.07205231 0.09815225 0.07600581 0.14666306 0.04598340 #> [19] 0.25463325 0.16538272 0.08420186 0.23473744 0.06856281 0.17004895 #> [25] 0.22618425 0.06933439 0.07672390 0.12162285 0.14324368 0.14440827 #> [31] 0.23368195 0.08659100 0.11722574 0.24416527 0.13947440 0.28604738 #> [37] 0.08057311 0.11586475 0.07294106 0.07079641 0.13274784 0.07402237 #> [43] 0.14003320 0.11678770 0.13505417 0.06700914 0.06674076 0.10383276 #> [49] 0.21379294 0.17696335 result$deseq_estimate  # DESeq2 results #>        baseMean log2FoldChange     lfcSE        stat     pvalue      padj #> otu_1  2.523916   -0.007959025 0.2519496 -0.03164913 0.97475186 0.9892808 #> otu_2  3.436181   -0.445880472 0.2632859 -1.67359558 0.09421011 0.9892808 #> otu_3  3.542517   -0.394760811 0.2633018 -1.48732907 0.13692792 0.9892808 #> otu_4  2.702925    0.233294799 0.2553894  0.91069198 0.36245769 0.9892808 #> otu_5  2.694906   -0.091829484 0.2572253 -0.35677492 0.72126031 0.9892808 #> otu_6  3.287608    0.058651776 0.2642521  0.22185078 0.82443004 0.9892808 #> otu_7  4.150850   -0.308246138 0.2647080 -1.16052986 0.24583314 0.9892808 #> otu_8  3.555650   -0.308896891 0.2626516 -1.17228830 0.24108133 0.9892808 #> otu_9  3.090175   -0.251029922 0.2446089 -1.02344368 0.30609811 0.9892808 #> otu_10 2.675081   -0.252289726 0.2561637 -0.97892159 0.32761872 0.9892808 #> otu_11 2.749900    0.039529520 0.2178270  0.18227420 0.85536754 0.9892808 #> otu_12 3.390569    0.160924136 0.2630611  0.61090560 0.54126208 0.9892808 #> otu_13 2.356214    0.194703220 0.2500851  0.77559202 0.43798991 0.9892808 #> otu_14 3.205661    0.192716051 0.2641421  0.72725190 0.46707166 0.9892808 #> otu_15 3.301207   -0.464400160 0.2633714 -1.74236099 0.08144530 0.9892808 #> otu_16 3.130311    0.068904985 0.2638552  0.26125914 0.79389267 0.9892808 #> otu_17 4.059487   -0.097712013 0.2640602 -0.36948165 0.71176875 0.9892808 #> otu_18 4.936842    0.053908758 0.2616827  0.20581280 0.83693715 0.9892808 #> otu_19 2.433494   -0.363959631 0.2494307 -1.44767679 0.14770746 0.9892808 #> otu_20 2.736376    0.156101373 0.2577149  0.60598515 0.54452462 0.9892808 #> otu_21 3.243073   -0.144220223 0.2639479 -0.54652933 0.58470213 0.9892808 #> otu_22 2.633467   -0.013117419 0.2535946 -0.05154981 0.95888741 0.9892808 #> otu_23 3.018337    0.028005740 0.2637688  0.10623129 0.91539885 0.9892808 #> otu_24 2.658367    0.150500957 0.2572649  0.58326522 0.55971477 0.9892808 #> otu_25 2.140747    0.042978792 0.2488796  0.17205591 0.86339357 0.9892808 #> otu_26 3.019768    0.027651694 0.2637470  0.10490246 0.91645321 0.9892808 #> otu_27 3.255246    0.141706746 0.2642600  0.53474221 0.59282813 0.9892808 #> otu_28 3.335342   -0.177098228 0.2630580 -0.67289343 0.50101509 0.9892808 #> otu_29 1.956007    0.456759743 0.2498016  1.76909120 0.07687866 0.9892808 #> otu_30 3.517628   -0.309509409 0.2627584 -1.17253684 0.24098159 0.9892808 #> otu_31 2.388890    0.035671304 0.2509830  0.14209553 0.88700455 0.9892808 #> otu_32 3.218515   -0.228363278 0.2638465 -0.86312957 0.38806623 0.9892808 #> otu_33 2.797655    0.030497385 0.2609264  0.11688845 0.90694845 0.9892808 #> otu_34 2.127118   -0.256186889 0.2466555 -1.03492011 0.30070622 0.9892808 #> otu_35 3.643876    0.044228160 0.2634726  0.16759310 0.86690340 0.9892808 #> otu_36 2.505223   -0.083204924 0.2488969 -0.33428091 0.73816759 0.9892808 #> otu_37 2.873749    0.251044749 0.2627610  0.94886216 0.34269072 0.9892808 #> otu_38 3.371951    0.271340396 0.2635050  1.02123215 0.30714446 0.9892808 #> otu_39 3.037822   -0.148152551 0.2636697 -0.56179228 0.57425755 0.9892808 #> otu_40 3.034731   -0.417094381 0.2635909 -1.56179566 0.11833613 0.9892808 #> otu_41 3.759194    0.003548958 0.2639096  0.01343493 0.98928080 0.9892808 #> otu_42 3.121752    0.101448484 0.2641010  0.38304575 0.70168584 0.9892808 #> otu_43 3.885608   -0.023449549 0.2639198 -0.08883389 0.92921392 0.9892808 #> otu_44 3.571744   -0.062952952 0.2639640 -0.23829804 0.81164994 0.9892808 #> otu_45 3.560160   -0.208034179 0.2633832 -0.78692916 0.43132333 0.9892808 #> otu_46 2.933184   -0.104467686 0.2634991 -0.39666457 0.69161483 0.9892808 #> otu_47 3.075949   -0.019733425 0.2640999 -0.07469519 0.94045724 0.9892808 #> otu_48 2.803747    0.030671416 0.2615479  0.11730384 0.90661928 0.9892808 #> otu_49 2.045793    0.273876722 0.2476936  1.09437629 0.27378998 0.9892808 #> otu_50 2.686524    0.149311832 0.2569471  0.58024839 0.56174712 0.9892808 result$normalised_count  # Normalized count data #> NULL"},{"path":"https://michaelagronah.com/power.nb/reference/dispersion_fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit the non-linear function to dispersion estimates ‚Äî dispersion_fit","title":"Fit the non-linear function to dispersion estimates ‚Äî dispersion_fit","text":"Dispersion estimated DESeq2 package. function fitted form  + b/(mean count) represents asymptotic dispersion level high abundance taxa, b captures additional dispersion variability.","code":""},{"path":"https://michaelagronah.com/power.nb/reference/dispersion_fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit the non-linear function to dispersion estimates ‚Äî dispersion_fit","text":"","code":"dispersion_fit(dispersion, logmean)"},{"path":"https://michaelagronah.com/power.nb/reference/dispersion_fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit the non-linear function to dispersion estimates ‚Äî dispersion_fit","text":"dispersion dispersion estimates deseq logmean vector log mean abundance","code":""},{"path":"https://michaelagronah.com/power.nb/reference/dispersion_fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit the non-linear function to dispersion estimates ‚Äî dispersion_fit","text":"list containing estimates b confidence intervals","code":""},{"path":"https://michaelagronah.com/power.nb/reference/dispersion_fit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit the non-linear function to dispersion estimates ‚Äî dispersion_fit","text":"","code":"logmean    =  rnorm(100) dispersion =  abs(rnorm(100)) dispersion_fit(dispersion,logmean) #> Warning: singular gradient #> Waiting for profiling to be done... #> $param #>   asymptDisp extraPois #> 1   1.040575         0 #>  #> $confint #>            2.5 % 97.5 % #> asymptDisp    NA     NA #> extraPois     NA     NA #>"},{"path":"https://michaelagronah.com/power.nb/reference/dispersion_fun.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Dispersion for Microbiome Data ‚Äî dispersion_fun","title":"Calculate Dispersion for Microbiome Data ‚Äî dispersion_fun","text":"function calculates dispersion value microbiome data based provided parameters: mean abundance, asymptotic dispersion, extra Poisson dispersion.","code":""},{"path":"https://michaelagronah.com/power.nb/reference/dispersion_fun.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Dispersion for Microbiome Data ‚Äî dispersion_fun","text":"","code":"dispersion_fun(mean_abund, asymptDisp, extraPois)"},{"path":"https://michaelagronah.com/power.nb/reference/dispersion_fun.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Dispersion for Microbiome Data ‚Äî dispersion_fun","text":"mean_abund Numeric value representing mean abundance taxa. asymptDisp Numeric value asymptotic dispersion (dispersion high abundance). extraPois Numeric value extra Poisson dispersion (model overdispersion).","code":""},{"path":"https://michaelagronah.com/power.nb/reference/dispersion_fun.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Dispersion for Microbiome Data ‚Äî dispersion_fun","text":"numeric value representing dispersion.","code":""},{"path":"https://michaelagronah.com/power.nb/reference/dispersion_fun.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Dispersion for Microbiome Data ‚Äî dispersion_fun","text":"dispersion calculated using formula: $$\\text{dispersion} = \\text{asymptDisp} + \\frac{\\text{extraPois}}{\\text{mean_abund}}$$","code":""},{"path":"https://michaelagronah.com/power.nb/reference/dispersion_fun.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Dispersion for Microbiome Data ‚Äî dispersion_fun","text":"","code":"mean_abund <- 10 asymptDisp <- 0.1 extraPois <- 0.05 dispersion_fun(mean_abund, asymptDisp, extraPois) #> [1] 0.105"},{"path":"https://michaelagronah.com/power.nb/reference/dnormmix.html","id":null,"dir":"Reference","previous_headings":"","what":"Density of a Normal Mixture Model ‚Äî dnormmix","title":"Density of a Normal Mixture Model ‚Äî dnormmix","text":"function calculates density normal mixture model given vector parameters unconstrained scale (softmax(prob), mean, log(sd)).","code":""},{"path":"https://michaelagronah.com/power.nb/reference/dnormmix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Density of a Normal Mixture Model ‚Äî dnormmix","text":"","code":"dnormmix(x, par, logmean, ..., log = FALSE)"},{"path":"https://michaelagronah.com/power.nb/reference/dnormmix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Density of a Normal Mixture Model ‚Äî dnormmix","text":"x Numeric vector values evaluate density. par vector parameters unconstrained scale, including: softmax(prob): Mixture probabilities (unconstrained scale, transformed via softmax). mean: Means normal components. log(sd): Logarithms standard deviations normal components. logmean Numeric value representing log mean parameter. ... Additional arguments passed genmixpars function. Defaults: two components (np = 2) quadratic model standard deviation parameters (sd_ord = 2). log Logical. TRUE, logarithm density returned. Default FALSE.","code":""},{"path":"https://michaelagronah.com/power.nb/reference/dnormmix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Density of a Normal Mixture Model ‚Äî dnormmix","text":"numeric vector density values (log-density values log = TRUE) mixture model.","code":""},{"path":"https://michaelagronah.com/power.nb/reference/dnormmix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Density of a Normal Mixture Model ‚Äî dnormmix","text":"","code":"# Example parameters x <- seq(-3, 3, length.out = 100) ## par <- c(-0.5, 0.5, log(0.8), log(1.2))  # Example: softmax probabilities, mean, log(sd) set.seed(101); par <- rnorm(11) logmean <- rep(0.1, length(x))  ## constant log mean  # Calculate density density <- dnormmix(x, par, logmean)  # Calculate log-density log_density <- dnormmix(x, par, logmean, log = TRUE)"},{"path":"https://michaelagronah.com/power.nb/reference/dnormmix0.html","id":null,"dir":"Reference","previous_headings":"","what":"Density function for the mixture of Gaussian distributions ‚Äî dnormmix0","title":"Density function for the mixture of Gaussian distributions ‚Äî dnormmix0","text":"takes pars three vectors (prob, mean, sd), constrained scale","code":""},{"path":"https://michaelagronah.com/power.nb/reference/dnormmix0.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Density function for the mixture of Gaussian distributions ‚Äî dnormmix0","text":"","code":"dnormmix0(x, probs, muvals, sdvals, log = FALSE)"},{"path":"https://michaelagronah.com/power.nb/reference/dnormmix0.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Density function for the mixture of Gaussian distributions ‚Äî dnormmix0","text":"x vector probs mixture proportions muvals values mean sdvals values standard deviataions log log scale","code":""},{"path":"https://michaelagronah.com/power.nb/reference/dnormmix0.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Density function for the mixture of Gaussian distributions ‚Äî dnormmix0","text":"likelihood","code":""},{"path":"https://michaelagronah.com/power.nb/reference/filter_low_count.html","id":null,"dir":"Reference","previous_headings":"","what":"Filter to remove low abundant taxa ‚Äî filter_low_count","title":"Filter to remove low abundant taxa ‚Äî filter_low_count","text":"Filter retain taxa least abund_thresh counts least sample_thresh samples","code":""},{"path":"https://michaelagronah.com/power.nb/reference/filter_low_count.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filter to remove low abundant taxa ‚Äî filter_low_count","text":"","code":"filter_low_count(   countdata,   metadata,   abund_thresh = 5,   sample_thresh = 3,   sample_colname,   group_colname )"},{"path":"https://michaelagronah.com/power.nb/reference/filter_low_count.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filter to remove low abundant taxa ‚Äî filter_low_count","text":"countdata otu table metadata dataframe 2 rows sample names group names abund_thresh minimum number taxa abundance threshold sample_thresh minimum number sample threshold sample_colname column names samples group_colname column names groups conditions","code":""},{"path":"https://michaelagronah.com/power.nb/reference/filter_low_count.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Filter to remove low abundant taxa ‚Äî filter_low_count","text":"filtered otu count data","code":""},{"path":"https://michaelagronah.com/power.nb/reference/gam_fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Title ‚Äî gam_fit","title":"Title ‚Äî gam_fit","text":"Title","code":""},{"path":"https://michaelagronah.com/power.nb/reference/gam_fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Title ‚Äî gam_fit","text":"","code":"gam_fit(   deseq_est_list,   true_lfoldchange_list,   true_lmean_list,   grid_len = 50,   alpha_level = 0.1 )"},{"path":"https://michaelagronah.com/power.nb/reference/gam_fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Title ‚Äî gam_fit","text":"deseq_est_list list containing fold change, pvalues estimates DESeq2 true_lfoldchange_list list containing simulated log fold change used  simulating count data true_lmean_list list containing simulated log mean count used  simulating count data grid_len number grids alpha_level significance level power calculations","code":""},{"path":"https://michaelagronah.com/power.nb/reference/gam_fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Title ‚Äî gam_fit","text":"list fit_2d fitted scam object power_estimate predicted power estimated using fit_2d combined_data tibble containing pvlaues used GAM fit","code":""},{"path":"https://michaelagronah.com/power.nb/reference/gen_parnames.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Parameter Names for Mixture Model ‚Äî gen_parnames","title":"Generate Parameter Names for Mixture Model ‚Äî gen_parnames","text":"function generates parameter names Gaussian mixture model based number components (np) order polynomial function (sd_ord) used model standard deviation parameters.","code":""},{"path":"https://michaelagronah.com/power.nb/reference/gen_parnames.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Parameter Names for Mixture Model ‚Äî gen_parnames","text":"","code":"gen_parnames(np, sd_ord)"},{"path":"https://michaelagronah.com/power.nb/reference/gen_parnames.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Parameter Names for Mixture Model ‚Äî gen_parnames","text":"np Integer. number Gaussian components mixture model. sd_ord Integer. order polynomial function used model standard deviation parameters. Possible values : 1: Linear function. 2: Quadratic function.","code":""},{"path":"https://michaelagronah.com/power.nb/reference/gen_parnames.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Parameter Names for Mixture Model ‚Äî gen_parnames","text":"character vector parameter names, including: Logit-transformed probabilities (logitprob_1, ..., logitprob_(np-1)). Mean parameters (mu_int_1, mu_slope_1, ..., component). Log-transformed standard deviations (logsd_.1_1, logsd_.L_1, ..., depending sd_ord np).","code":""},{"path":"https://michaelagronah.com/power.nb/reference/gen_parnames.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Parameter Names for Mixture Model ‚Äî gen_parnames","text":"","code":"# Generate parameter names for a 3-component mixture with linear standard deviation function gen_parnames(np = 3, sd_ord = 1) #>  [1] \"logitprob_1\" \"logitprob_2\" \"mu_int_1\"    \"mu_int_2\"    \"mu_int_3\"    #>  [6] \"mu_slope_1\"  \"mu_slope_2\"  \"mu_slope_3\"  \"logsd_.1_1\"  \"logsd_.1_2\"  #> [11] \"logsd_.1_3\"  \"logsd_.L_1\"  \"logsd_.L_2\"  \"logsd_.L_3\"   # Generate parameter names for a 4-component mixture with quadratic standard deviation function gen_parnames(np = 4, sd_ord = 2) #>  [1] \"logitprob_1\" \"logitprob_2\" \"logitprob_3\" \"mu_int_1\"    \"mu_int_2\"    #>  [6] \"mu_int_3\"    \"mu_int_4\"    \"mu_slope_1\"  \"mu_slope_2\"  \"mu_slope_3\"  #> [11] \"mu_slope_4\"  \"logsd_.1_1\"  \"logsd_.1_2\"  \"logsd_.1_3\"  \"logsd_.1_4\"  #> [16] \"logsd_.L_1\"  \"logsd_.L_2\"  \"logsd_.L_3\"  \"logsd_.L_4\"  \"logsd_.Q_1\"  #> [21] \"logsd_.Q_2\"  \"logsd_.Q_3\"  \"logsd_.Q_4\""},{"path":"https://michaelagronah.com/power.nb/reference/genmixpars.html","id":null,"dir":"Reference","previous_headings":"","what":"generate normal mixture parameters (prob vector, mean vector, sd vector for a specified set of 'x' values (logmean) ‚Äî genmixpars","title":"generate normal mixture parameters (prob vector, mean vector, sd vector for a specified set of 'x' values (logmean) ‚Äî genmixpars","text":"generate normal mixture parameters (prob vector, mean vector, sd vector specified set 'x' values (logmean)","code":""},{"path":"https://michaelagronah.com/power.nb/reference/genmixpars.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"generate normal mixture parameters (prob vector, mean vector, sd vector for a specified set of 'x' values (logmean) ‚Äî genmixpars","text":"","code":"genmixpars(x, pars, np = 2, sd_ord = 2)"},{"path":"https://michaelagronah.com/power.nb/reference/genmixpars.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"generate normal mixture parameters (prob vector, mean vector, sd vector for a specified set of 'x' values (logmean) ‚Äî genmixpars","text":"x independent variable pars parameter vector: first logit-probs (np-1), mean parameters (2 per component: intercepts, slopes), var parameters (varord + 1 per component: intercepts, slopes, quad coeffs, etc.) np number components mixture sd_ord order logsd model (2 = quadratic)","code":""},{"path":"https://michaelagronah.com/power.nb/reference/genmixpars.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"generate normal mixture parameters (prob vector, mean vector, sd vector for a specified set of 'x' values (logmean) ‚Äî genmixpars","text":"list","code":"probs: mixture proportions ()   muvals: mean values   sdvals: standard deviation values"},{"path":"https://michaelagronah.com/power.nb/reference/logfoldchange_fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit a mixture of Gaussian distributions to log fold change ‚Äî logfoldchange_fit","title":"Fit a mixture of Gaussian distributions to log fold change ‚Äî logfoldchange_fit","text":"standard deviation parameters modeled either linear quadratic functions log mean count mean parameter modeled linear functions log mean count","code":""},{"path":"https://michaelagronah.com/power.nb/reference/logfoldchange_fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit a mixture of Gaussian distributions to log fold change ‚Äî logfoldchange_fit","text":"","code":"logfoldchange_fit(   logmean,   logfoldchange,   ncore = 2,   max_sd_ord = 2,   max_np = 5,   minval = -5,   maxval = 5,   itermax = 100,   NP = 800,   seed = 100 )"},{"path":"https://michaelagronah.com/power.nb/reference/logfoldchange_fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit a mixture of Gaussian distributions to log fold change ‚Äî logfoldchange_fit","text":"logmean vector log mean abundance logfoldchange vector log fold change ncore number cores use max_sd_ord maximum order polynomial function fit standard deviation parameter. must either 1 (linear) 2(quadratic) max_np maximum number Gaussian components check minval minimum value DEoptim search maxval maximum value DEoptim search itermax maximum number iterations NP number population members DEoptim seed seed value","code":""},{"path":"https://michaelagronah.com/power.nb/reference/logfoldchange_fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit a mixture of Gaussian distributions to log fold change ‚Äî logfoldchange_fit","text":"list.","code":"par is a vector of the estimates of the mixture proportion,    the mean and standard deviation parameters,     np is the number of gaussian components fitted     sd_ord is the order for the function for the standard deviation     aic is the aic of the best fit"},{"path":"https://michaelagronah.com/power.nb/reference/logfoldchange_fit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit a mixture of Gaussian distributions to log fold change ‚Äî logfoldchange_fit","text":"","code":"logmean        =  rnorm(100) logfoldchange  =  rnorm(100) if (FALSE) { # \\dontrun{ logfoldchange_fit(logmean,logfoldchange) } # }"},{"path":"https://michaelagronah.com/power.nb/reference/logfoldchange_sim_fun.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate Log Fold Change Values ‚Äî logfoldchange_sim_fun","title":"Simulate Log Fold Change Values ‚Äî logfoldchange_sim_fun","text":"function generates simulated log fold change (LFC) values based provided log mean abundance LFC parameters. simulation ensures generated LFC values remain within specified maximum range iterating convergence maximum iteration limit reached.","code":""},{"path":"https://michaelagronah.com/power.nb/reference/logfoldchange_sim_fun.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate Log Fold Change Values ‚Äî logfoldchange_sim_fun","text":"","code":"logfoldchange_sim_fun(   logmean_sim,   logfoldchange_param,   max_lfc = 15,   max_iter = 10000,   seed = 121 )"},{"path":"https://michaelagronah.com/power.nb/reference/logfoldchange_sim_fun.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate Log Fold Change Values ‚Äî logfoldchange_sim_fun","text":"logmean_sim numeric vector simulated log mean abundances. logfoldchange_param list containing parameters log fold change simulation: par: Optimal parameters log fold change fit. np: Optimal number components log fold change model. sd_ord: Order polynomial used standard deviation parameter log fold change. max_lfc numeric value specifying maximum allowable absolute log fold change value. Default 15. max_iter integer specifying maximum number iterations allowed ensure simulated LFC values within max_lfc range. Default 10,000. seed random-number seed","code":""},{"path":"https://michaelagronah.com/power.nb/reference/logfoldchange_sim_fun.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate Log Fold Change Values ‚Äî logfoldchange_sim_fun","text":"numeric vector simulated log fold change values (lfc).","code":""},{"path":"https://michaelagronah.com/power.nb/reference/logfoldchange_sim_fun.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate Log Fold Change Values ‚Äî logfoldchange_sim_fun","text":"","code":"# Define simulated log mean abundance logmean_sim <- rnorm(100, mean = 0, sd = 1)  # Define parameters for log fold change simulation logfoldchange_param <- list(   par = c(1, -0.5, 0.2), # Example parameters   np = 2,                # Number of components   sd_ord = 2             # Order of polynomial for SD )  # Simulate log fold change values logfoldchange_sim_fun(   logmean_sim = logmean_sim,   logfoldchange_param = logfoldchange_param,   max_lfc = 10,   max_iter = 5000 ) #> Error in genmixpars(logmean, par, ...): number of pars (3) != expected (11) (np = 2, sd_ord = 2)"},{"path":"https://michaelagronah.com/power.nb/reference/logmean_fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit a mixture of Gaussian Distributions to log mean count of taxa. ‚Äî logmean_fit","title":"Fit a mixture of Gaussian Distributions to log mean count of taxa. ‚Äî logmean_fit","text":"optimal number components fit chosen using parametric bootstrap method","code":""},{"path":"https://michaelagronah.com/power.nb/reference/logmean_fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit a mixture of Gaussian Distributions to log mean count of taxa. ‚Äî logmean_fit","text":"","code":"logmean_fit(logmean, sig = 0.05, max.comp = 4, max.boot = 100, verb = FALSE)"},{"path":"https://michaelagronah.com/power.nb/reference/logmean_fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit a mixture of Gaussian Distributions to log mean count of taxa. ‚Äî logmean_fit","text":"logmean vector log mean count taxa sig significance level compare p-value used parametric bootstrap calculation max.comp maximum number Gaussian components compare sequentially max.boot maximum number bootstraps simulations verb TRUE, prints updates iterations algorithm","code":""},{"path":"https://michaelagronah.com/power.nb/reference/logmean_fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit a mixture of Gaussian Distributions to log mean count of taxa. ‚Äî logmean_fit","text":"list containing optimal number Gaussian components fitted; mean variance parameter estimates fit","code":""},{"path":"https://michaelagronah.com/power.nb/reference/logmean_fit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit a mixture of Gaussian Distributions to log mean count of taxa. ‚Äî logmean_fit","text":"","code":"logmean  = rnorm(100) logmean_fit(logmean,sig=0.05,max.comp=4,max.boot=100) #> number of iterations= 24  #> number of iterations= 19  #> number of iterations= 30  #> number of iterations= 15  #> One of the variances is going to zero;  trying new starting values. #> One of the variances is going to zero;  trying new starting values. #> One of the variances is going to zero;  trying new starting values. #> One of the variances is going to zero;  trying new starting values. #> number of iterations= 52  #> number of iterations= 29  #> number of iterations= 13  #> number of iterations= 17  #> number of iterations= 15  #> number of iterations= 9  #> number of iterations= 6  #> number of iterations= 63  #> number of iterations= 21  #> number of iterations= 46  #> number of iterations= 131  #> number of iterations= 42  #> number of iterations= 13  #> number of iterations= 9  #> number of iterations= 35  #> number of iterations= 32  #> number of iterations= 102  #> number of iterations= 117  #> number of iterations= 74  #> number of iterations= 7  #> number of iterations= 163  #> number of iterations= 97  #> number of iterations= 47  #> number of iterations= 25  #> number of iterations= 21  #> number of iterations= 17  #> number of iterations= 18  #> number of iterations= 40  #> number of iterations= 114  #> number of iterations= 19  #> number of iterations= 37  #> number of iterations= 8  #> number of iterations= 47  #> number of iterations= 16  #> number of iterations= 153  #> number of iterations= 7  #> number of iterations= 10  #> number of iterations= 8  #> number of iterations= 130  #> number of iterations= 36  #> number of iterations= 41  #> number of iterations= 11  #> number of iterations= 10  #> number of iterations= 13  #> One of the variances is going to zero;  trying new starting values. #> One of the variances is going to zero;  trying new starting values. #> One of the variances is going to zero;  trying new starting values. #> number of iterations= 139  #> number of iterations= 132  #> number of iterations= 6  #> number of iterations= 115  #> number of iterations= 59  #> number of iterations= 116  #> number of iterations= 15  #> number of iterations= 111  #> number of iterations= 27  #> number of iterations= 56  #> number of iterations= 14  #> number of iterations= 30  #> number of iterations= 48  #> number of iterations= 27  #> number of iterations= 138  #> number of iterations= 102  #> number of iterations= 12  #> number of iterations= 81  #> number of iterations= 24  #> number of iterations= 103  #> number of iterations= 105  #> number of iterations= 3  #> number of iterations= 26  #> number of iterations= 21  #> number of iterations= 32  #> number of iterations= 3  #> number of iterations= 25  #> number of iterations= 88  #> number of iterations= 16  #> number of iterations= 41  #> number of iterations= 9  #> number of iterations= 8  #> number of iterations= 95  #> number of iterations= 109  #> number of iterations= 16  #> number of iterations= 83  #> number of iterations= 27  #> number of iterations= 22  #> number of iterations= 32  #> number of iterations= 84  #> number of iterations= 7  #> number of iterations= 26  #> number of iterations= 14  #> number of iterations= 30  #> number of iterations= 14  #> number of iterations= 32  #> number of iterations= 52  #> number of iterations= 46  #> number of iterations= 230  #> number of iterations= 60  #> number of iterations= 19  #> number of iterations= 62  #> number of iterations= 164   #> Decision: Select 1 Component(s)  #> $param #>       sigma          mu #> 1 0.8854284 -0.09361792 #>  #> $components #> [1] 1 #>"},{"path":"https://michaelagronah.com/power.nb/reference/logmean_sim_fun.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate Log Means for OTUs ‚Äî logmean_sim_fun","title":"Simulate Log Means for OTUs ‚Äî logmean_sim_fun","text":"function generates log means specified number OTUs (Operational Taxonomic Units) based provided parameters. single mean specified, log means drawn normal distribution. multiple means corresponding weights specified, log means drawn mixture normal distributions.","code":""},{"path":"https://michaelagronah.com/power.nb/reference/logmean_sim_fun.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate Log Means for OTUs ‚Äî logmean_sim_fun","text":"","code":"logmean_sim_fun(logmean_param, notu)"},{"path":"https://michaelagronah.com/power.nb/reference/logmean_sim_fun.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate Log Means for OTUs ‚Äî logmean_sim_fun","text":"logmean_param list containing parameters distribution: mu: single value vector mean(s) normal mixture distribution. sigma: standard deviation(s) normal mixture distribution. lambda: (Optional) vector weights components mixture distribution. Required mu one value. notu integer specifying number OTUs simulate.","code":""},{"path":"https://michaelagronah.com/power.nb/reference/logmean_sim_fun.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate Log Means for OTUs ‚Äî logmean_sim_fun","text":"numeric vector simulated log means specified number OTUs.","code":""},{"path":"https://michaelagronah.com/power.nb/reference/logmean_sim_fun.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate Log Means for OTUs ‚Äî logmean_sim_fun","text":"","code":"# Example 1: Single normal distribution params_single <- list(mu = 0, sigma = 1) logmean_sim_fun(logmean_param = params_single, notu = 100) #>   [1]  0.588804559  0.018840329 -0.128790271  0.752496971 -0.399255906 #>   [6]  1.081400706  0.210597235  0.561122468 -3.235268480 -0.408438489 #>  [11]  0.086857457 -1.233233022 -0.795154691  0.234989829  0.975505185 #>  [16] -0.530451833  1.695697500  0.876304868  0.109421045 -0.635344486 #>  [21] -0.118364286 -0.154237577  2.116618561  1.100128458 -0.819765570 #>  [26] -0.863878467 -0.607813648  0.352841463  1.673934219 -0.095797827 #>  [31] -0.008518563 -0.853967162 -1.385920191 -0.234312127  0.050198725 #>  [36] -0.011763044 -0.287874087  0.004836868 -0.041233812 -0.864532804 #>  [41] -0.461601559  0.643573427  0.083646677 -0.033285172  1.595839010 #>  [46]  1.174637946 -0.558311630  1.201119692  0.709478256 -1.391145646 #>  [51]  1.485382867  0.100518870  0.177750365  1.206317686 -0.577546719 #>  [56]  2.570748407  0.645752073  0.915836534  0.265288537 -0.816880567 #>  [61]  0.664690047 -0.613967752 -0.623195126 -0.892805087  0.343857366 #>  [66]  0.512134788  0.108372727 -0.048747047 -0.091832450 -1.710781319 #>  [71]  1.459615281 -1.546137673  1.074037870 -0.703739042  0.894174528 #>  [76] -1.791556874 -0.298701440 -0.485264045  0.546933877  0.157692671 #>  [81]  0.201747809  1.189789713  1.476213261 -0.072073716 -0.587393779 #>  [86]  0.048525665  1.463390773 -0.351330927 -1.857615398  0.139194309 #>  [91]  0.411052658  0.972752901 -1.830893591 -1.147215164 -0.331935125 #>  [96] -0.400009625 -1.454717135 -0.951836000  0.880163256 -0.273236970  # Example 2: Mixture of normal distributions params_mixture <- list(   mu = c(-1, 1),   sigma = c(0.5, 0.5),   lambda = c(0.4, 0.6) ) logmean_sim_fun(logmean_param = params_mixture, notu = 100) #>   [1]  1.07744271 -1.11013574  0.29199882  0.23752221  0.65965639  1.55845995 #>   [7] -0.22890341 -0.58526000  1.00212000  0.78297234  0.22541964  0.81061556 #>  [13]  1.28211600  1.24283393  1.35963503  0.72253582  1.19586581  0.61232017 #>  [19]  1.75995383  0.52364736  1.14851342  1.75705388  1.35994604  1.14359244 #>  [25]  1.39829637 -1.26083780 -1.16414629  0.62887193  0.91880367 -0.46752819 #>  [31]  0.87978830  0.94707690 -1.05944634 -0.73739947 -0.68956245 -1.26346583 #>  [37]  0.66197647 -0.99468868  0.34960863  1.47404840  0.98774757  1.59103912 #>  [43] -0.52717179 -1.02793827 -0.69664963  0.78745479  1.13610278 -0.60488949 #>  [49]  0.96317087  1.24321158  0.90640924  1.34453481  1.87729199 -0.32897706 #>  [55]  1.56078233 -1.25835323 -1.66873834  0.87769701  1.07946100  1.05645775 #>  [61]  0.09311995 -1.20568103  0.95103307 -0.28806749 -0.23346582 -1.28153537 #>  [67]  0.06234719  1.81378310  0.09323532 -1.34175236  0.52057204  0.53741247 #>  [73] -1.51307439  1.21639119 -1.75864429  1.52531795 -0.99508794 -0.57365879 #>  [79] -1.34172861  0.63710936 -0.48854276  0.36986132 -0.63184816 -1.13680878 #>  [85] -1.64210922 -0.89917840 -1.17117605 -0.45470720 -1.80448968  1.11290635 #>  [91]  1.34502294  2.07389505  1.79880209 -1.52891432 -1.10106423 -1.69833116 #>  [97]  0.86992949 -1.21649609  0.97279906  1.56975558"},{"path":"https://michaelagronah.com/power.nb/reference/myrnormmix.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulating from a mixture of Gaussian ‚Äî myrnormmix","title":"Simulating from a mixture of Gaussian ‚Äî myrnormmix","text":"Simulating mixture Gaussian","code":""},{"path":"https://michaelagronah.com/power.nb/reference/myrnormmix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulating from a mixture of Gaussian ‚Äî myrnormmix","text":"","code":"myrnormmix(par, logmean, ...)"},{"path":"https://michaelagronah.com/power.nb/reference/myrnormmix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulating from a mixture of Gaussian ‚Äî myrnormmix","text":"par parameters (mean, standard deviation mixture proportion mixture Gaussian) logmean log mean count taxa ... parameters taken genmixpars","code":""},{"path":"https://michaelagronah.com/power.nb/reference/myrnormmix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulating from a mixture of Gaussian ‚Äî myrnormmix","text":"random values  mixture Gaussian","code":""},{"path":"https://michaelagronah.com/power.nb/reference/nllfun.html","id":null,"dir":"Reference","previous_headings":"","what":"Objective function ‚Äî nllfun","title":"Objective function ‚Äî nllfun","text":"Objective function","code":""},{"path":"https://michaelagronah.com/power.nb/reference/nllfun.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Objective function ‚Äî nllfun","text":"","code":"nllfun(par, vals, logmean, np, sd_ord)"},{"path":"https://michaelagronah.com/power.nb/reference/nllfun.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Objective function ‚Äî nllfun","text":"par parameters mixture Gaussian vals values log fold change logmean log mean count np number Gaussian components sd_ord order polynomial function model standard deviation parameters (1 - linear function 2- quad)","code":""},{"path":"https://michaelagronah.com/power.nb/reference/nllfun.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Objective function ‚Äî nllfun","text":"value objective function","code":""},{"path":"https://michaelagronah.com/power.nb/reference/optimal.comp.html","id":null,"dir":"Reference","previous_headings":"","what":"Computes the optimal number of gaussian components for log mean count ‚Äî optimal.comp","title":"Computes the optimal number of gaussian components for log mean count ‚Äî optimal.comp","text":"number gaussian components determined using using parametric bootstrap","code":""},{"path":"https://michaelagronah.com/power.nb/reference/optimal.comp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Computes the optimal number of gaussian components for log mean count ‚Äî optimal.comp","text":"","code":"optimal.comp(logmean, sig = 0.05, max.comp = 4, max.boot = 100)"},{"path":"https://michaelagronah.com/power.nb/reference/optimal.comp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Computes the optimal number of gaussian components for log mean count ‚Äî optimal.comp","text":"logmean vector log mean abundances taxa sig significance level compare p-value max.comp maximum number Gaussian components compare sequentially max.boot maximum number bootstraps simulations","code":""},{"path":"https://michaelagronah.com/power.nb/reference/optimal.comp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Computes the optimal number of gaussian components for log mean count ‚Äî optimal.comp","text":"best number components fitting distribution log mean abundance","code":""},{"path":"https://michaelagronah.com/power.nb/reference/optimal.comp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Computes the optimal number of gaussian components for log mean count ‚Äî optimal.comp","text":"","code":"logmean  = rnorm(100) optimal.comp(logmean,sig=0.05,max.comp=4,max.boot=100) #> number of iterations= 27  #> number of iterations= 51  #> number of iterations= 10  #> number of iterations= 8  #> number of iterations= 38  #> number of iterations= 8  #> number of iterations= 31  #> number of iterations= 56  #> number of iterations= 26  #> number of iterations= 81  #> number of iterations= 88  #> number of iterations= 43  #> number of iterations= 27  #> number of iterations= 103  #> number of iterations= 19  #> number of iterations= 66  #> One of the variances is going to zero;  trying new starting values. #> number of iterations= 34  #> number of iterations= 96  #> number of iterations= 17  #> number of iterations= 19  #> number of iterations= 11  #> number of iterations= 31  #> number of iterations= 25  #> number of iterations= 4  #> number of iterations= 38  #> number of iterations= 16  #> number of iterations= 61  #> number of iterations= 29  #> number of iterations= 6  #> number of iterations= 51  #> number of iterations= 31  #> number of iterations= 44  #> number of iterations= 20  #> number of iterations= 11  #> number of iterations= 50  #> number of iterations= 52  #> number of iterations= 22  #> number of iterations= 45  #> number of iterations= 99  #> number of iterations= 35  #> number of iterations= 10  #> number of iterations= 21  #> number of iterations= 24  #> number of iterations= 3  #> One of the variances is going to zero;  trying new starting values. #> number of iterations= 36  #> number of iterations= 256  #> number of iterations= 39  #> number of iterations= 17  #> number of iterations= 31  #> number of iterations= 85  #> number of iterations= 28  #> number of iterations= 64  #> number of iterations= 20  #> number of iterations= 45  #> number of iterations= 82  #> number of iterations= 27  #> number of iterations= 41  #> number of iterations= 128  #> number of iterations= 63  #> number of iterations= 109  #> number of iterations= 96  #> number of iterations= 34  #> number of iterations= 59  #> number of iterations= 23  #> number of iterations= 23  #> number of iterations= 22  #> number of iterations= 7  #> number of iterations= 112  #> number of iterations= 39  #> number of iterations= 10  #> number of iterations= 25  #> One of the variances is going to zero;  trying new starting values. #> One of the variances is going to zero;  trying new starting values. #> number of iterations= 50  #> number of iterations= 44  #> number of iterations= 128  #> number of iterations= 27  #> number of iterations= 30  #> number of iterations= 13  #> number of iterations= 34  #> number of iterations= 70  #> number of iterations= 20  #> number of iterations= 128  #> number of iterations= 102  #> number of iterations= 65  #> number of iterations= 61  #> number of iterations= 77  #> number of iterations= 28  #> number of iterations= 32  #> number of iterations= 51  #> number of iterations= 14  #> number of iterations= 18  #> number of iterations= 80  #> number of iterations= 29  #> number of iterations= 19  #> number of iterations= 5  #> number of iterations= 31  #> number of iterations= 3  #> number of iterations= 69  #> number of iterations= 26  #> number of iterations= 93  #> number of iterations= 118  #> number of iterations= 114   #> Decision: Select 1 Component(s)  #> [1] 1"},{"path":"https://michaelagronah.com/power.nb/reference/polyfun.html","id":null,"dir":"Reference","previous_headings":"","what":"General-purpose log-likelihood function, vectorized sum(pars*x^i) ‚Äî polyfun","title":"General-purpose log-likelihood function, vectorized sum(pars*x^i) ‚Äî polyfun","text":"General-purpose log-likelihood function, vectorized sum(pars*x^)","code":""},{"path":"https://michaelagronah.com/power.nb/reference/polyfun.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"General-purpose log-likelihood function, vectorized sum(pars*x^i) ‚Äî polyfun","text":"","code":"polyfun(pars, x)"},{"path":"https://michaelagronah.com/power.nb/reference/polyfun.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"General-purpose log-likelihood function, vectorized sum(pars*x^i) ‚Äî polyfun","text":"pars parameters x log mean count","code":""},{"path":"https://michaelagronah.com/power.nb/reference/polyfun.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"General-purpose log-likelihood function, vectorized sum(pars*x^i) ‚Äî polyfun","text":"values representing output polynomial fuction (f(x))","code":""},{"path":"https://michaelagronah.com/power.nb/reference/polyfun.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"General-purpose log-likelihood function, vectorized sum(pars*x^i) ‚Äî polyfun","text":"","code":"polyfun(pars = c(1, 2, 3), x = 1:5) #> [1]  6 17 34 57 86 polyfun(pars = c(1, 0, 3), x = 1) #> [1] 4"},{"path":"https://michaelagronah.com/power.nb/reference/power_fun_ss.html","id":null,"dir":"Reference","previous_headings":"","what":"Power function ‚Äî power_fun_ss","title":"Power function ‚Äî power_fun_ss","text":"Power function","code":""},{"path":"https://michaelagronah.com/power.nb/reference/power_fun_ss.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Power function ‚Äî power_fun_ss","text":"","code":"power_fun_ss(   deseq_est_list,   true_logfoldchange,   true_logmean,   sample_vec,   alpha_level = 0.1,   notu )"},{"path":"https://michaelagronah.com/power.nb/reference/power_fun_ss.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Power function ‚Äî power_fun_ss","text":"deseq_est_list list containing fold change, pvalues estimates DESeq2 true_logfoldchange list containing simulated log fold change used  simulating count data true_logmean list containing simulated log mean counte used  simulating count data sample_vec vector sample sizes alpha_level sign containing simulated log fold change used  simulating count data notu number OTUs fit GAM covariates tensor product (ie,interaction log mean abundance absolute log fold changes spline sample sizes log mean abundance log fold changes related directly,hence interaction sample size quite related log mean abundance log fold changes directly","code":""},{"path":"https://michaelagronah.com/power.nb/reference/read_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract specified data from a list of datasets ‚Äî read_data","title":"Extract specified data from a list of datasets ‚Äî read_data","text":"function extracts specific component (data) list datasets. component extract specified extract_name parameter, function returns list containing extracted data dataset.","code":""},{"path":"https://michaelagronah.com/power.nb/reference/read_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract specified data from a list of datasets ‚Äî read_data","text":"","code":"read_data(dataset_list, extract_name)"},{"path":"https://michaelagronah.com/power.nb/reference/read_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract specified data from a list of datasets ‚Äî read_data","text":"dataset_list list datasets data extracted. element list assumed dataset (typically list dataframe). extract_name string representing name component column extracted dataset dataset_list. function looks name within dataset.","code":""},{"path":"https://michaelagronah.com/power.nb/reference/read_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract specified data from a list of datasets ‚Äî read_data","text":"list containing extracted data. element corresponds extracted component datasets dataset_list. names list elements taken names dataset_list.","code":""},{"path":"https://michaelagronah.com/power.nb/reference/read_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract specified data from a list of datasets ‚Äî read_data","text":"","code":"# Example dataset list dataset1 <- list(countdata = matrix(1:9, nrow = 3), metadata = data.frame(id = 1:3)) dataset2 <- list(countdata = matrix(10:18, nrow = 3), metadata = data.frame(id = 4:6)) dataset_list <- list(dataset1 = dataset1, dataset2 = dataset2)  # Extract 'countdata' from each dataset in the list result <- read_data(dataset_list, \"countdata\") print(result) #> $dataset1 #>      [,1] [,2] [,3] #> [1,]    1    4    7 #> [2,]    2    5    8 #> [3,]    3    6    9 #>  #> $dataset2 #>      [,1] [,2] [,3] #> [1,]   10   13   16 #> [2,]   11   14   17 #> [3,]   12   15   18 #>"},{"path":"https://michaelagronah.com/power.nb/reference/rnormmix0.html","id":null,"dir":"Reference","previous_headings":"","what":"general-purpose normal-mixture deviate generator: takes matrices of probabilities, means, sds ‚Äî rnormmix0","title":"general-purpose normal-mixture deviate generator: takes matrices of probabilities, means, sds ‚Äî rnormmix0","text":"general-purpose normal-mixture deviate generator: takes matrices probabilities, means, sds","code":""},{"path":"https://michaelagronah.com/power.nb/reference/rnormmix0.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"general-purpose normal-mixture deviate generator: takes matrices of probabilities, means, sds ‚Äî rnormmix0","text":"","code":"rnormmix0(n, probs, muvals, sdvals)"},{"path":"https://michaelagronah.com/power.nb/reference/rnormmix0.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"general-purpose normal-mixture deviate generator: takes matrices of probabilities, means, sds ‚Äî rnormmix0","text":"n number observations probs mixture proportions muvals values mean sdvals values standard deviation","code":""},{"path":"https://michaelagronah.com/power.nb/reference/rnormmix0.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"general-purpose normal-mixture deviate generator: takes matrices of probabilities, means, sds ‚Äî rnormmix0","text":"simulations","code":""},{"path":[]}]
